<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>Prototypica</title>
        <link>https://proto.typi.ca</link>
        <description>A blog about hardware and software.</description>
        <generator>Zola</generator>
        <language>en</language>
        <atom:link href="https://proto.typi.ca/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Sun, 06 Jun 2021 00:00:00 +0000</lastBuildDate>
        <item>
            <title>Porting Rust Microtetris</title>
            <pubDate>Sun, 06 Jun 2021 00:00:00 +0000</pubDate>
            <link>https://proto.typi.ca/rust-porting-chips/</link>
            <guid>https://proto.typi.ca/rust-porting-chips/</guid>
            <description>&lt;p&gt;I wanted to try &lt;a href=&quot;http:&#x2F;&#x2F;marekmiettinen.fi&#x2F;micropong&#x2F;index.html&quot;&gt;Marek Miettinen&#x27;s microtetris&lt;&#x2F;a&gt; but I didn&#x27;t have a Cortex-M0 chip (ThumbV6). I decided to try porting it to M4 (ThumbV7).&lt;&#x2F;p&gt;
&lt;p&gt;I was impressed with how straightforward this was. After a bit of a discussion with the compiler, everything worked on the first try. The architecture and peripherals of the two chips are very similar, so it was not a huge deal, but as you can see, &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;micropong&#x2F;commit&#x2F;421ccc1860495c121f5b9a3d3de9bef7eb9cc756&quot;&gt;the diff&lt;&#x2F;a&gt; is not trivial either.&lt;&#x2F;p&gt;
&lt;p&gt;I didn&#x27;t spend any time debugging. With so many of the invariants specified using the Rust type system, I didn&#x27;t need to. I probably did spend more time getting it to compile than I would have done in C, but once I flashed it to the device, I was directly on to thinking about improvements. &lt;&#x2F;p&gt;
&lt;p&gt;This code only polls for button presses during part of the game loop, and the controls feel a bit unresponsive. It could probably do with an interrupt routine just for the controls. Doing so would probably require adding explicit button debouncing.&lt;&#x2F;p&gt;
&lt;p&gt;The point is, if I had been doing this in C I surely would have missed something. I&#x27;d be spending this time debugging some code I had not written and had never seen run correctly.&lt;&#x2F;p&gt;
&lt;p&gt;Don&#x27;t get me wrong, there are still plenty of ways to write embedded code in Rust that doesn&#x27;t work. For example, I had many builds of &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;making-custom-i2c-displays&#x2F;&quot;&gt;this&lt;&#x2F;a&gt; that just plain did nothing. There are also always going to be those times when you&#x27;re fiddling with the hardware for what will turn out to be a software problem, and vice versa.&lt;&#x2F;p&gt;
&lt;p&gt;There are other rough edges. The generated code constraining these features is pretty cumbersome. For more on that, see the example in therealprof&#x27;s post on &lt;a href=&quot;https:&#x2F;&#x2F;therealprof.github.io&#x2F;blog&#x2F;roadmap-2021-arbitrary-size-primitives&#x2F;&quot;&gt;arbitrary integer primitives&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;In general however, I think this type of reduction in friction is really important. I spend a lot of time in large codebases, where you spend much more time debugging and managing interactions with existing code than you do writing truly new code. The more that your tools can help ensure the continued correctness of what you have already written, the better. It frees up time and gives you the confidence to change and improve things in ways you would have otherwise avoided.&lt;&#x2F;p&gt;
&lt;p&gt;Check out the code &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;micropong&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;Further reading: I came across &lt;a href=&quot;https:&#x2F;&#x2F;www.ecorax.net&#x2F;as-above-so-below-1&#x2F;&quot;&gt;this post&lt;&#x2F;a&gt; by Pablo Mansanet that has a similar sentiment and goes into much more detail.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Late Night Latches</title>
            <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
            <link>https://proto.typi.ca/late-night-latches/</link>
            <guid>https://proto.typi.ca/late-night-latches/</guid>
            <description>&lt;h3 id=&quot;the-setting&quot;&gt;The Setting&lt;&#x2F;h3&gt;
&lt;p&gt;If you&#x27;re like me, you&#x27;ll enjoy a little late night soldering to relax and get away from screens for a while.&lt;&#x2F;p&gt;
&lt;p&gt;A good pairing I can recommend for this is to put on a YouTube video by &lt;a href=&quot;https:&#x2F;&#x2F;www.youtube.com&#x2F;user&#x2F;bigclivedotcom&quot;&gt;BigClive&lt;&#x2F;a&gt;. His videos are fun and informative, they are calmly presented, so you don&#x27;t have to be watching the screen the entire time, and he has a great voice. You&#x27;ll learn more about LEDs, power supplies, and ion generators than you ever thought you wanted to know.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;latches&quot;&gt;Latches&lt;&#x2F;h3&gt;
&lt;p&gt;Latches are a basic building-block for computing. With a latch, you can build a flip-flop. With a bunch of those, you can build a register, SRAM, all kinds of good stuff.&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s fun to build things like this to get a feel for how they work in practice.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s a very simple latch using an SCR. (AKA &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Thyristor&quot;&gt;thyristor&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;SCR-latch-schematic.png&quot; alt=&quot;SCR Latch Schematic&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Except for maybe &lt;a href=&quot;https:&#x2F;&#x2F;hackaday.io&#x2F;project&#x2F;7975-one-transistor-latch&quot;&gt;one weird trick&lt;&#x2F;a&gt;, you can&#x27;t make a latch using a single transistor. When you remove current from the base, current ceases to flow from the collector to the emitter.&lt;&#x2F;p&gt;
&lt;p&gt;An SCR, with an additional P-N junction, is a little different. You can apply a pulse to the gate, allowing current to flow through the component like a diode. The continuous current flow keeps the pathway open.&lt;&#x2F;p&gt;
&lt;p&gt;As you can see in the schematic, to reset this latch, you can break the current flow by pressing the normally closed switch. After you release the button, current won&#x27;t flow until you trigger the gate again.&lt;&#x2F;p&gt;
&lt;p&gt;This is great for turning on and off this... I think it&#x27;s a Christmas tree bulb. I&#x27;m not sure where this lamp came from.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;SCR-latch-lamp.jpeg&quot; alt=&quot;SCR Latch and Sky Bison&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;It&#x27;s maybe not great for a digital circuit however. As soon as you remove the load, it unlatches.&lt;&#x2F;p&gt;
&lt;p&gt;For example, here&#x27;s the same basic circuit with a novelty blinking LED. (I skimped on the switches. It was late, remember. Bare wires are switches.) &lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;SCR-latch-LED.jpeg&quot; alt=&quot;Appa watching a blinky&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This is an RGB LED that offers no control, it has internal circuitry that runs through a cycle of blinking color patterns.&lt;&#x2F;p&gt;
&lt;p&gt;When the LED reaches the end of its first cycle, &lt;strong&gt;sometimes&lt;&#x2F;strong&gt; it unlatches. It&#x27;s unreliable. Sometimes the current is low enough that the path through the SCR can&#x27;t be sustained. Maybe it depends on temperature, maybe there is variability in the timing of the LED patterns, who knows.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s try another latch.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;OR-gate-feedback-latch-schematic.png&quot; alt=&quot;OR Gate Feedback Latch Schematic&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This one uses a single OR gate of a 74LS32. When we drive pin 1 positive, the gate turns on, and the feedback from the output to the second input keeps the gate open, and we have our latch. It&#x27;s not shown on the schematic, but you can reset the latch by breaking the feedback connection.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;OR-gate-latch.jpeg&quot; alt=&quot;Sorry about the floating inputs&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;With this circuit, we can remove the load without changing the state of our latch.&lt;&#x2F;p&gt;
&lt;p&gt;One thing this latch also demonstrated is the importance of decoupling capacitors. (There&#x27;s a 0.1µF capacitor behind the chip there, I didn&#x27;t know I was going to be photographing this.) When I was testing the circuit on a breadboard I was getting false triggering when connecting power and other glitches. After adding the bypass cap, this issue went away. More on that &lt;a href=&quot;https:&#x2F;&#x2F;www.vagrearg.org&#x2F;content&#x2F;decoupling&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;I should note that I&#x27;m a Software Engineer who likes to experiment, not an Electrical Engineer. Let me know if I&#x27;ve made any mistakes!&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>I²C VFD Display using Rust on an Arm Cortex MCU</title>
            <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
            <link>https://proto.typi.ca/rust-i2c-vfd/</link>
            <guid>https://proto.typi.ca/rust-i2c-vfd/</guid>
            <description>&lt;p&gt;&lt;img src=&quot;&#x2F;vfd-with-mcu.jpeg&quot; alt=&quot;1234 on VFD&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;In the previous two blog posts we have built an &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;making-custom-i2c-displays&#x2F;&quot;&gt;LED bar display&lt;&#x2F;a&gt; and a &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;rust-i2c-bubble-display&#x2F;&quot;&gt;7-segment LED display&lt;&#x2F;a&gt;. We&#x27;re taking a break from LEDs for our third display and basking in the blue-green glow of a Vacuum Fluorescent Display. &lt;&#x2F;p&gt;
&lt;p&gt;If you pull one out of an old microwave, VCR, or stereo you might not have a datasheet. Mine are from a &lt;a href=&quot;https:&#x2F;&#x2F;www.goldmine-elec-products.com&#x2F;prodinfo.asp?number=G2200&quot;&gt;junk box&lt;&#x2F;a&gt;, and I was not able to find any documentation.&lt;&#x2F;p&gt;
&lt;p&gt;Michał Słomkowski has a great walkthrough detailing how to &lt;a href=&quot;https:&#x2F;&#x2F;slomkowski.eu&#x2F;tutorials&#x2F;determining-the-pinout-of-the-unknown-vacuum-fluorescent-display&#x2F;&quot;&gt;determine the pinout and power requirements of your VFD&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;These displays require more power than our LEDs, and we&#x27;re certainly not going to be able to hook this up directly to our microcontroller. One way to handle this is to use a dedicated VFD control chip such as the MAX6921. &lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;MAX6921.jpeg&quot; alt=&quot;MAX6921 and Socket, weird to have a picture of a chip we are not even using&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Instead, we are going to use a bunch more components and hook it up &lt;a href=&quot;https:&#x2F;&#x2F;microcontrollerslab.com&#x2F;how-to-use-transistor-as-a-switch&#x2F;&quot;&gt;using transistors as switches&lt;&#x2F;a&gt;. We&#x27;ll hook the microcontroller up to the base of the transistors which will turn on a higher voltage path powering the display.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;oops-all-anodes&quot;&gt;Oops, All Anodes&lt;&#x2F;h3&gt;
&lt;p&gt;Unlike our LEDs, each of the segments of the VFD is an anode. The grids that turn each digit on and off are also anodes.&lt;&#x2F;p&gt;
&lt;p&gt;There are a few different ways to hook it up. This is what I decided on.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;vfd-segment-schematic.png&quot; alt=&quot;VFD segment schematic&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;You can use a general purpose BJT or MOSFET here. I used 2N3904 transistors because I had a bunch of them, and I also used some 2N2222s because I like how many 2s are in the name. It&#x27;s the weekend, we don&#x27;t need to justify ourselves.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll need one of these for each segment and each grid pin.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;vfd-trans.jpeg&quot; alt=&quot;VFD transistors on a breadboard&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;We can see that with this configuration the display will default to being powered. When the transistor is on, the segment or grid will be pulled low. This means our MCU outputs will be active-low.&lt;&#x2F;p&gt;
&lt;p&gt;What about the cathode? VFDs, like other vacuum tubes, have hot filaments running across the grids. This is the cathode. We&#x27;ll keep it steadily powered. I have not tried it, but these displays should run more evenly if you drive the filament with alternating current. We will get away with DC here but if you have an appropriate transformer or some other source of AC, it would be worth experimenting.&lt;&#x2F;p&gt;
&lt;p&gt;In my case, the anodes require 8.2V, and I ended up needing 0.8V across the filament. I used a 12V power supply with an adjustable buck converter for a high voltage rail for the segments and grids. I then added a 3V regulator to set up another power rail for the MCU and the filament. I added a resistor plus a little slider pot to trim down the filament until it was just below the point where it would glow red.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;software&quot;&gt;Software&lt;&#x2F;h3&gt;
&lt;p&gt;This particular display really wants to be a clock, so we will need to adapt our code on the host to handle the fact that the most significant digit only goes up to 1. We also have the colon segment which I didn&#x27;t need, so I just left it off.&lt;&#x2F;p&gt;
&lt;p&gt;On the firmware side, we have pretty much everything we need already built for the previous displays. The only real changes needed are to alter the segments to be active low and start out in the HIGH state. You can find the code &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;here&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust I²C Bubble Display</title>
            <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
            <link>https://proto.typi.ca/rust-i2c-bubble-display/</link>
            <guid>https://proto.typi.ca/rust-i2c-bubble-display/</guid>
            <description>&lt;p&gt;In the &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;making-custom-i2c-displays&#x2F;&quot;&gt;previous post&lt;&#x2F;a&gt; we looked at a simple LED bar display. This time we have a tiny 7-segment bubble display.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;bubble-display.jpeg&quot; alt=&quot;LED Bubble Display&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s first decide how we&#x27;re hooking this up. To reduce the number of pins, displays like these are usually wired internally so that all the segments for each of the digits are connected together. Additionally, either the anodes or the cathodes of the LEDs for each digit are connected together. In this case, we have a &lt;a href=&quot;https:&#x2F;&#x2F;lastminuteengineers.com&#x2F;seven-segment-arduino-tutorial&#x2F;&quot;&gt;common cathode display&lt;&#x2F;a&gt;. This means we can only turn a single set of segments on at a time, effectively, we can only send one number to the display at a time. If it&#x27;s an 8 for example we turn them all on, if it&#x27;s 9, one fewer. To work around this, we need to multiplex the display. We&#x27;ll turn off all digits but the first while sending the segments for the first position, turn all but the second digit off while sending the segments for the second digit, and so on. We&#x27;ll do this fast enough for nobody to notice.&lt;&#x2F;p&gt;
&lt;p&gt;We also need to consider power constraints. If we hook the segment pins directly (via current limiting resistors) to output pins supplying 3.3v, and the digit pins directly to open drain pins, the worst case, with 7 segments and the decimal point turned on, we&#x27;ll get all 8 feeding into a single pin. I hooked up an ammeter, 3.3v, experimented with current-limiting resistors to get the brightness I was happy with and measured about 14mA. Our pins can sink about 20mA, so we&#x27;ll be in spec. See the third display, for what to do when you&#x27;re over the power budget and this is not an option.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;bubble-display-schematic.png&quot; alt=&quot;LED Bubble Display Schematic&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;This is how I connected mine. I chose those pins so that I could add a circuit board with minimal wiring that snapped onto the microcontroller board with pin headers. Your constraints might be different. &lt;&#x2F;p&gt;
&lt;p&gt;Note also that you can get chips that do most of this for you. Two popular chips in the hobbyist community are the MAX7219 and TM1637.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s look at the code. You can see the complete code for the displays in &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;the repo&lt;&#x2F;a&gt;. Much of it is the same as the &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;making-custom-i2c-displays&#x2F;&quot;&gt;previous display&lt;&#x2F;a&gt;, so check that for an explanation.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;re going to use a couple new features for our IO pins. We turn on our digits by switching from high-impedance state to ground, a digital low signal. Our segment pins on the other hand, we turn on with a logic high value. It would be nice to consider the electrical reality only at setup time and once that is done, put it aside and deal more directly with the logical state of our display. You’ll see a similar idea when datasheets talk about “asserting” a pin. A signal may be active high, or active low. Asserting the signal is setting the active state. &lt;&#x2F;p&gt;
&lt;p&gt;The &lt;code&gt;OutputSwitch&lt;&#x2F;code&gt; trait is what we want here.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Digit pins are defined like this
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    pins_a
        .pa8
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_open_drain_output_with_state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pins_a.crh, State::High)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_active_low_switch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ones
&#x2F;&#x2F; Segment pins are defined like this
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    pins_a
        .pa7
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output_with_state&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; pins_a.crl, State::Low)
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
        .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_active_high_switch&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; g
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re calling &lt;code&gt;into_active_low_switch()&lt;&#x2F;code&gt; or &lt;code&gt;into_active_high_switch()&lt;&#x2F;code&gt; which returns a &lt;code&gt;Switch&lt;&#x2F;code&gt; type, so we can define our &lt;code&gt;Display&lt;&#x2F;code&gt; like so &lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Display {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;digits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: [Switch&amp;lt;Pxx&amp;lt;Output&amp;lt;OpenDrain&amp;gt;&amp;gt;, ActiveLow&amp;gt;; 4],
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;segments&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: [Switch&amp;lt;Pxx&amp;lt;Output&amp;lt;PushPull&amp;gt;&amp;gt;, ActiveHigh&amp;gt;; 8],
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This allows us to use the more natural &lt;code&gt;digit.on()&lt;&#x2F;code&gt; and &lt;code&gt;digit.off()&lt;&#x2F;code&gt;. The other thing you&#x27;ll notice is that &lt;code&gt;output_with_state&lt;&#x2F;code&gt; lets us define the initial state of the pin right up front.&lt;&#x2F;p&gt;
&lt;p&gt;There&#x27;s one snag with the IO pins. To make wiring easier, we want to use PA15 which is by default used for JTAG. Since JTAG is often used for debugging, it&#x27;s on by default. We are debugging over SWD, so we can disable JTAG to use PA15 as a general purpose pin. Since we&#x27;re using the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;stm32f1xx-hal&#x2F;0.7.0&#x2F;stm32f1xx_hal&#x2F;&quot;&gt;HAL&lt;&#x2F;a&gt;, rather than our device just glitching or failing, the compiler will remind us if we try to use a pin that is set up incorrectly.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s how we remap the pin.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; afio = device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;AFIO&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;constrain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb2);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(pa15, _, _) = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MAPR&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;::disable_jtag(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; afio.mapr, pins_a.pa15, pins_b.pb3, pins_b.pb4);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We give &lt;code&gt;disable_jtag&lt;&#x2F;code&gt; the pin we got from &lt;code&gt;split&lt;&#x2F;code&gt;ing gpioa, and it returns us a nice shiny generic pin, we can use like the others.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;driving-the-display&quot;&gt;Driving the display&lt;&#x2F;h3&gt;
&lt;p&gt;The most important new thing we will need is a timer to continually refresh the display. This means we&#x27;ll want a new RTIC task. We&#x27;ll set up TIM1, a generic timer to invoke our interrupt at a particular refresh rate.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; refresh_timer =
    Timer::tim1(device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;TIM1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &amp;amp;clocks, &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb2).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;start_count_down&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;280.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;hz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
refresh_timer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;listen&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(Event::Update);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll display a single digit of our display on each invocation of the interrupt, so four invocations will be a full cycle. We&#x27;ll want at least 4 × 60hz, but 60hz is a bit annoying if you&#x27;re moving your head, so let&#x27;s go with 4 × 70hz, so 280hz. You can slow that right down to a few hertz to see exactly what is going on when you&#x27;re debugging.&lt;&#x2F;p&gt;
&lt;p&gt;The function to select the digit to turn on looks like this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;select_digit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;display&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; Display, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;digit_position&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; digit_select = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&amp;lt; digit_position;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(i, digit) in display.digits.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter_mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(digit_select &amp;gt;&amp;gt; i) &amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
            digit.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;on&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
            digit.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;off&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re making use of &lt;code&gt;on()&lt;&#x2F;code&gt; and &lt;code&gt;off()&lt;&#x2F;code&gt; from &lt;code&gt;switch_hal&lt;&#x2F;code&gt; that I mentioned, to make this a little more readable.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s our new set of shared resources:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Resources {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i2c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: I2C1,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;display&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: Display,
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;refresh_timer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: CountDownTimer&amp;lt;TIM1&amp;gt;,
    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;([0,0,0,0])]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;display_buffer&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;; MESSAGE_LENGTH],
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The i2c event task will fill the display buffer, which will be shared with our display task.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(binds = I2C1_EV, resources = [i2c, display_buffer], priority = 2)]

#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(binds = TIM1_UP, resources = [refresh_timer, display, display_buffer], priority = 1)]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The &lt;code&gt;i2c&lt;&#x2F;code&gt; device, the &lt;code&gt;display&lt;&#x2F;code&gt; and the &lt;code&gt;refresh_timer&lt;&#x2F;code&gt; are initialized by init and only used in one task each, so we don&#x27;t need to worry about synchronization. The data we want to display will be shared in &lt;code&gt;display_buffer&lt;&#x2F;code&gt;. We want to read our incoming data right away, so we&#x27;ll give the I²C task a higher priority than our display refresh timer. Since our &lt;code&gt;display_buffer&lt;&#x2F;code&gt; is shared between tasks with two different priorities, in the lower priority task, where we can be preempted, RTIC will give us a mutex proxy object we can use to access the resource. We&#x27;ll ignore the fact that in this very particular case, our 4 bytes of data should be in a single, aligned machine word, so our access should be atomic anyway. This code will continue to work if we were to add a byte to our buffer. &lt;&#x2F;p&gt;
&lt;p&gt;In the highest priority task this resource appears in, our I²C events task, we can write to the buffer directly, since we won&#x27;t be preempted.&lt;&#x2F;p&gt;
&lt;p&gt;Here&#x27;s the complete task:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(binds = TIM1_UP, resources = [refresh_timer, display, display_buffer], priority = 1)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;tim1_up&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: tim1_up::Context) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;usize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; display = c.resources.display;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; display_buffer = c.resources.display_buffer;

    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; frame: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    display_buffer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;lock&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;buf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| {
        frame = buf[*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
    });
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;select_digit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; display, *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;output_segments&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; display, frame);

    *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MESSAGE_LENGTH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;DISPLAY_DIGIT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    }
    c.resources.refresh_timer.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_update_interrupt_flag&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re keeping track of which digit we are displaying in a &lt;code&gt;static mut&lt;&#x2F;code&gt; variable which will persist across interrupt invocations. Each time we hit the interrupt, we grab a byte for a single digit, turn on that digit in the display, output the segments, and increment the digit for the next pass. Here we might also want to do some data transformation. For my purposes, I wanted to do the conversion on the host system, so we&#x27;re just dumping the bits to the segments. They are arranged as standard 7-segment display a–f plus the decimal point, but that is not a particularly useful mapping. You could create a kind of &amp;quot;font&amp;quot; table mapping numbers to segments for numerals. It might be nice for the first byte sent from the host to specify decimal, hexadecimal, or raw mode. One tip if you do this, you might consider up-front how you want to handle the difference between displaying a zero and no value at all.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;getting-the-message&quot;&gt;Getting the message&lt;&#x2F;h3&gt;
&lt;p&gt;RTIC and the Rust compiler will help us keep track of where we need mutually exclusive access to a resource, but it&#x27;s up to us to make sure that we keep everything logically consistent for our application. For example, we could update our buffer after each byte received from our host, after all, it&#x27;s going to be fast enough, and it won&#x27;t really matter if we&#x27;re displaying half of one value and half of another for a split second. (I am chuckling to myself that I&#x27;m getting into &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Screen_tearing&quot;&gt;screen tearing&lt;&#x2F;a&gt; when talking about a 7 segment LED display.) Worse though, might be if communication is interrupted, or the host just sends an incomplete message. So let&#x27;s not send the message to the display until we get a complete payload from the host.&lt;&#x2F;p&gt;
&lt;p&gt;We&#x27;ll clear at the beginning of the transaction.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;READ_COUNT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PAYLOAD &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;= [&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MESSAGE_LENGTH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;];
    i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    i2c.sr2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll ignore extra bytes if the host sends too many.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rx_ne&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rx = i2c.dr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;READ_COUNT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;MESSAGE_LENGTH &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PAYLOAD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;[*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;READ_COUNT&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;] = rx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    }
    *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;READ_COUNT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll write to the buffer at the end of the message.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stopf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;READ_COUNT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
        *display_buffer = *&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;PAYLOAD&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
    }
    i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| {
        w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    });
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;h3 id=&quot;using-the-display&quot;&gt;Using the display&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s try hooking up our display. Let&#x27;s hook it up to an Arduino again, but this time we&#x27;ll send random bytes for that alien microprocessor look.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Wire.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;setup&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;randomSeed&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;analogRead&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
}

byte randNumber;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;beginTransmission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x34&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;int&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;; i &amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;; i++) {
    randNumber = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;random&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;256&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
    Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(randNumber);
  }
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;endTransmission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;20&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;div class=&quot;loopvid&quot;&gt;
    &lt;video autoplay loop muted playsinline&gt;
        &lt;source src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;vid&amp;#x2F;pink-led-bar.mp4&quot; type=&quot;video&#x2F;mp4&quot; alt=&quot;random led segment display&quot;&gt;
    &lt;&#x2F;video&gt;
&lt;&#x2F;div&gt;
&lt;p&gt;Great, now let&#x27;s try hooking up to the Raspberry Pi. You can check the &lt;a href=&quot;https:&#x2F;&#x2F;pinout.xyz&#x2F;&quot;&gt;pinout here&lt;&#x2F;a&gt;. It looks like we need pins 1(3V),3(SDA - Data),5(SCL - Clock), and 6(Ground).&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s run &lt;code&gt;i2cdetect&lt;&#x2F;code&gt; from the &lt;a href=&quot;https:&#x2F;&#x2F;i2c.wiki.kernel.org&#x2F;index.php&#x2F;I2C_Tools&quot;&gt;i2ctools package&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pi@koroks:~&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; $ i2cdetect&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; 1
     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;          -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;10:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;20:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;30:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;40:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;50:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;60:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;70:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- --      
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We don&#x27;t show up, that&#x27;s no fun.&lt;&#x2F;p&gt;
&lt;p&gt;We don&#x27;t show up because while we do respond with the ACK signal when we match our address, and when we receive a byte, we are currently not doing anything when the master device asks us to reply. Linux mainly deals with SMBus devices. SMBus is a flavour of I²C with a few extra rules and expectations. I²C scanners usually send a test byte and request that we transmit.&lt;&#x2F;p&gt;
&lt;p&gt;To handle this, all we need to do is reply when transmit is expected (TX_E), and the byte transfer is not finished (BTF).&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;tx_e&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() &amp;amp;&amp;amp; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;btf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_clear&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    i2c.dr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;dr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Let&#x27;s reply with 4. 4 is a good number.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pi@koroks:~&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; $ i2cdetect&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; 1
     &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;00:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;          -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;10:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;20:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;30:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- 34 -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;40:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;50:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;60:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;70:&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; -- -- -- -- -- -- -- --  
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Now we show up!&lt;&#x2F;p&gt;
&lt;p&gt;Now we can use the standard tools to talk to our display. As an example, let&#x27;s use &lt;code&gt;i2cset&lt;&#x2F;code&gt;. We need to tell it to use i2c device 1, set our address 0x34, and give it 4 bytes of data corresponding to the raw segments we want to turn on.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;pi@koroks:~&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; $ i2cset&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt; -y&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; 1 0x34 0x5B 0x6d 0x63 0x39 i
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;img src=&quot;&#x2F;i2c-led-raspi-ferris.jpeg&quot; alt=&quot;Ferris watching over our I²C LED display&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Koroks courtesy of my 11-year-old. Ferris The Squishable Rustacean by &lt;a href=&quot;http:&#x2F;&#x2F;edunham.net&quot;&gt;E. Dunham&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Making Custom I²C Displays</title>
            <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
            <link>https://proto.typi.ca/making-custom-i2c-displays/</link>
            <guid>https://proto.typi.ca/making-custom-i2c-displays/</guid>
            <description>&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;fed93ef60ed629c500.jpg&quot; alt=&quot;3 i2c displays using rust&quot;&#x2F;&gt;
&lt;p&gt;If you want to add a small display to your microcontroller project, there are a number of options available. One of my favourite inexpensive and easily available options are these tiny OLED displays.&lt;&#x2F;p&gt;
&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;a97d542fcf8ee56000.jpg&quot; alt=&quot;Micropong Tetris on SSD1306&quot;&#x2F;&gt;
&lt;p&gt;You can also find 7-Segment LED displays, LED matrix displays and LCDs. These often use the I²C interface, which is handy because you only need to use two data pins to talk to them. I²C is pretty ubiquitous, so you&#x27;ll be able to hook them up to pretty much any microcontroller or computer you&#x27;re likely to encounter. Additionally, since I²C is a shared bus, you can even chain multiple displays and sensors together.&lt;&#x2F;p&gt;
&lt;p&gt;So how do they work? These devices have their own embedded microcontrollers. They&#x27;re hidden everywhere these days.&lt;&#x2F;p&gt;
&lt;p&gt;Incidentally, if you&#x27;re wondering where the chip is on these little SSD1306 OLED displays it&#x27;s not immediately apparent. The circuit board contains some support components, but no chip. The answer is it&#x27;s embedded in the flex cable connected to the screen itself. It&#x27;s the yellow box in the image below.&lt;&#x2F;p&gt;
&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;e2e5a54b1fe09ce400.png&quot; alt=&quot;Core on ribbon in SSD1306&quot;&#x2F;&gt;
&lt;p&gt;I wanted something a little different from what is commercially available, so I built my own. I&#x27;ll walk through how I went about making three different displays. The first is an array of pink LEDs. This could be used to indicate status or activity or used as a bar graph. For the second one I just &lt;em&gt;had&lt;&#x2F;em&gt; to use one of these awesome little 7-segment LED bubble displays. You might recognize the vintage calculator look. For the love of the blue-green glow, the third display is a VFD, a Vacuum Fluorescent Display.&lt;&#x2F;p&gt;
&lt;p&gt;Please let me know on Twitter &lt;a href=&quot;https:&#x2F;&#x2F;twitter.com&#x2F;needtungsten&quot;&gt;@NeedTungsten&lt;&#x2F;a&gt; if this helps you build your own display, I&#x27;d love to see it!&lt;&#x2F;p&gt;
&lt;p&gt;This was also an opportunity for me to learn about embedded development using &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;what&#x2F;embedded&quot;&gt;Rust&lt;&#x2F;a&gt; and provide a detailed example of a project that is a little more than blinking a few leds—though we&#x27;ll certainly blink a few here. If you don&#x27;t care so much about the details of the implementation feel free to skip the Rust stuff and check out the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;git repository&lt;&#x2F;a&gt;. You can flash the code and use the device with an Arduino, a Raspberry Pi, Circuit Python, Linux or whatever you want as the host.&lt;&#x2F;p&gt;
&lt;p&gt;I have a number of these ARM Cortex-M &amp;quot;Blue-Pill&amp;quot; clone boards, and frankly, they&#x27;re not great. If I can press them into service as permanent display modules, to use them up, that will suit me fine.&lt;&#x2F;p&gt;
&lt;p&gt;To get our bearings with the hardware, the software, and the communication protocol, let&#x27;s start with a simple array of 8 LEDs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;development-environment&quot;&gt;Development Environment&lt;&#x2F;h3&gt;
&lt;p&gt;If you have not already done so, you might want to start out with a simple LED blinky project to make sure you have all your tools set up correctly. Here are some resources to get started:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&#x2F;stm32f1xx-hal&quot;&gt;Quickstart for the STM32F1xx&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lupyuen&#x2F;stm32-blue-pill-rust&quot;&gt;Blue Pill Rust&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jonathanklimt.de&#x2F;electronics&#x2F;programming&#x2F;embedded-rust&#x2F;rust-on-stm32-2&#x2F;&quot;&gt;Rust on STM32&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;You can compile this &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;first example&lt;&#x2F;a&gt; with &lt;code&gt;cargo build --release --bin i2c-leds&lt;&#x2F;code&gt; and flash it to the device with &lt;code&gt;cargo flash --release --bin i2c-leds --chip STM32F103C8&lt;&#x2F;code&gt;. For debug output &lt;code&gt;cargo embed --release --bin i2c-leds --chip STM32F103C8&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;led-bar-display&quot;&gt;LED Bar Display&lt;&#x2F;h3&gt;
&lt;p&gt;Let&#x27;s walk through the code first, and I&#x27;ll talk about the hardware as we go. &lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_main&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
#![&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;no_std&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;panic_handler&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;panic&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;info&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;PanicInfo) -&amp;gt; ! {
  rprintln!(&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;quot;, info);
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{}
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We declare &lt;code&gt;no_std&lt;&#x2F;code&gt; so we don&#x27;t pull in the parts of the Rust Standard Library for things like multithreading and file I&#x2F;O that require an underlying Operating System.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;no_main&lt;&#x2F;code&gt; lets us declare our own entry point. The reset vector of the microcontroller will be set up to jump to our main entrypoint after doing a few things like initializing the RAM.&lt;&#x2F;p&gt;
&lt;p&gt;Similar to our main entrypoint, we need to declare a panic handler. There are a number of options here, depending on your method of debugging. You can use a simple &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;panic-halt&quot;&gt;panic-halt&lt;&#x2F;a&gt; and add a breakpoint. Or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;cortex-m&#x2F;tree&#x2F;master&#x2F;panic-itm&quot;&gt;panic-itm&lt;&#x2F;a&gt; or &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rust-embedded&#x2F;cortex-m&#x2F;tree&#x2F;master&#x2F;panic-semihosting&quot;&gt;panic_semihosting&lt;&#x2F;a&gt;. I&#x27;ve been using &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;rtt-target&#x2F;0.3.1&#x2F;rtt_target&#x2F;&quot;&gt;rtt&lt;&#x2F;a&gt; for flashing and logging, so I defined my own panic handler to print to output to the same channel. &lt;a href=&quot;https:&#x2F;&#x2F;probe.rs&quot;&gt;probe-rs&lt;&#x2F;a&gt; is pretty great, well worth checking out.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;concurrency&quot;&gt;Concurrency&lt;&#x2F;h3&gt;
&lt;p&gt;It&#x27;s not so critical for this first simple display with 8 leds, but for the other two displays at least, we&#x27;ll need to handle two tasks simultaneously. We&#x27;ll be receiving data from the host and at the same time multiplexing digits to drive the display.&lt;&#x2F;p&gt;
&lt;p&gt;The way I²C works is the host system generates the clock signal and sends requests on the shared bus. The slave device, which is what we are implementing, listens for its address and sends acknowledgement pulses after reading data from the bus. The master receives these ACKs and knows it can move on to the next request. If we are busy updating our display when the data is ready, we are not going to be efficiently servicing the bus. The protocol does actually provide for this, if we don&#x27;t send the ACK right away, the clock is held until we do. This is known as clock stretching.&lt;&#x2F;p&gt;
&lt;p&gt;We can&#x27;t always rely on this! One problem I ran into when testing on the Raspberry Pi, was a buggy clock stretching implementation (in the Broadcom chip). It looks like instead of correctly stretching the clock, they instead mask it. This causes glitches since when the clock signal is unmasked you&#x27;ll often get a partial unaccounted for clock pulse which throws everything out of sync. Read the details &lt;a href=&quot;http:&#x2F;&#x2F;www.advamation.com&#x2F;knowhow&#x2F;raspberrypi&#x2F;rpi-i2c-bug.html&quot;&gt;here&lt;&#x2F;a&gt;. (This is not the only I²C issue I&#x27;ve come across. It&#x27;s not even the only clock stretching issue, see here for another &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;maarten-pennings&#x2F;CCS811&quot;&gt;issue with the ESP8266&lt;&#x2F;a&gt;.)&lt;&#x2F;p&gt;
&lt;p&gt;Even without these bugs though, that&#x27;s no way to live! Our system is plenty fast enough to get the bits off the wire. The way to do this efficiently is by using interrupts. The STM32F103 provides a hardware I²C interface that handles the clock and data for us. Data pulses are received serially on the SDA pin and accumulate in a &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Shift_register&quot;&gt;shift register&lt;&#x2F;a&gt;. Once the register is full, the system fires an interrupt. At this time we need to read the data and clear flags to acknowledge various conditions.&lt;&#x2F;p&gt;
&lt;p&gt;Just like in multithreaded code, we&#x27;re going to need to manage shared access to resources across concurrent execution contexts. There&#x27;s some interesting experimentation going on right now in the embedded Rust community right now. therealprof has a good &lt;a href=&quot;https:&#x2F;&#x2F;therealprof.github.io&#x2F;blog&#x2F;interrupt-comparison&#x2F;&quot;&gt;comparison of resource sharing implementations&lt;&#x2F;a&gt; that&#x27;s well worth checking out.&lt;&#x2F;p&gt;
&lt;p&gt;Again, for this simplest display, there&#x27;s not much concurrency, we&#x27;re doing setup and then we&#x27;re either servicing the interrupt or idling. We are, however, using the same framework for all three displays, so let&#x27;s take a look at the code.&lt;&#x2F;p&gt;
&lt;p&gt;For this project, I chose to use &lt;a href=&quot;https:&#x2F;&#x2F;rtic.rs&#x2F;0.5&#x2F;book&#x2F;en&#x2F;&quot;&gt;RTIC&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;rtic&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;app&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(device = stm32f1xx_hal::stm32, peripherals = true)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;APP&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: () = {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;Resources {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;i2c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: I2C1,
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;leds&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: [Pxx&amp;lt;Output&amp;lt;PushPull&amp;gt;&amp;gt;; 8],
    }
    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: init::Context) -&amp;gt; init::LateResources {
        
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Here we set up the device, and initialize `i2c` and `leds`
        
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;rtic::pend(Interrupt::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;I2C1_EV&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
        init::LateResources { i2c, leds }
    }

    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;idle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;idle&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(_: idle::Context) -&amp;gt; ! {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{}
    }

    #[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(binds = I2C1_EV, resources = [i2c, leds], priority = 2)]
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;i2c1_ev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: i2c1_ev::Context) {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i2c = c.resources.i2c;
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; leds = c.resources.leds;

        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Here we read i2c data and output to leds
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
};
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We declare our shared resources at the top of our APP pseudomodule, in this case our i2c interface and our array of LEDs. RTIC calls our &lt;code&gt;init&lt;&#x2F;code&gt; function with a context, providing access to the device peripherals, we do setup and return LateResources. RTIC provides tools to safely access these shared resources in tasks, including interrupts. Crucially, all interrupts are disabled until after the initialization of &lt;code&gt;Resources&lt;&#x2F;code&gt; so we can be certain they will be valid inside our interrupt handler.&lt;&#x2F;p&gt;
&lt;p&gt;I&#x27;ll have more to say about RTIC later.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;rtic::pend(Interrupt::I2C1_EV)&lt;&#x2F;code&gt; is a convenience function for setting the interrupt vector. If you&#x27;re not using RTIC you&#x27;ll want to nest your vectors directly using &lt;code&gt;cortex_m::peripheral::NVIC::unmask(Interrupt::I2C1_EV);&lt;&#x2F;code&gt;. This sets the entrypoint for our &lt;code&gt;I2C1_EV&lt;&#x2F;code&gt; task. We&#x27;ll jump to this task any time the I²C hardware peripheral has an event we need to handle. Because this task is the highest priority and can&#x27;t be preempted, and because tasks are not re-entrant, and because our processor is single core, inside this task we can access our shared resources without a critical section or any other locking.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;device-initialization&quot;&gt;Device Initialization&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; device: stm32f1xx_hal::stm32::Peripherals = c.device;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc = device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;RCC&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;constrain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; flash = device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;FLASH&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;constrain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; _clocks = rcc
    .cfgr
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;use_hse&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;8.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;mhz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;hclk&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;mhz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;sysclk&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;24.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;mhz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pclk1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;mhz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pclk2&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;12.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;mhz&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;())
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;freeze&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; flash.acr);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we take ownership over the device peripherals. &lt;code&gt;Peripherals&lt;&#x2F;code&gt; is a singleton with mostly &lt;a href=&quot;https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;book&#x2F;static-guarantees&#x2F;zero-cost-abstractions.html&quot;&gt;zero sized types&lt;&#x2F;a&gt; only used at compile time to let us know when we have done something inconsistent.&lt;&#x2F;p&gt;
&lt;p&gt;RCC is Reset and Clock Control. We&#x27;ll use the &lt;code&gt;RCC&lt;&#x2F;code&gt; &lt;a href=&quot;https:&#x2F;&#x2F;rust-unofficial.github.io&#x2F;patterns&#x2F;patterns&#x2F;creational&#x2F;builder.html&quot;&gt;builder&lt;&#x2F;a&gt; to configure our clock tree. As you can imagine, the timing of the system components is interdependent, so we configure it all at once and freeze that configuration. &lt;code&gt;hse&lt;&#x2F;code&gt; is the external oscillator that we have already determined is 8Mhz. The bus and system clock &lt;code&gt;hclk&lt;&#x2F;code&gt; and &lt;code&gt;sysclk&lt;&#x2F;code&gt; we&#x27;ll set to the same speed at a multiple of our external clock source. We&#x27;ll be using the I2C1 interface and, checking the reference manual, it&#x27;s part of APB1, so we&#x27;ll need to be sure to enable clock PCLK1 to make sure it&#x27;s powered on. Reading the manual you&#x27;ll also see references to registers such as RCC_APB1ENR. We won&#x27;t need to write to these directly, the &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;stm32f1xx-hal&#x2F;0.7.0&#x2F;stm32f1xx_hal&#x2F;&quot;&gt;HAL&lt;&#x2F;a&gt; is looking after configuring these using the code above. I recommend setting up your IDE to let you click directly into the supporting crates, so you can see for yourself whenever you&#x27;re curious.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Speaking of curiosity, it&#x27;s easy to get the system into an unresponsive state where it won&#x27;t accept requests to flash new code to the device. A great way to do this is to misconfigure the clock! 
It is not bricked, here&#x27;s how to fix it. You should have either a jumper, or a button labelled boot0. For normal operation this signal is tied low. When pulled high, rather than running user-flashed code, the system will run the bootloader code. Since we are flashing via the debug port, and not USB, we&#x27;re not too concerned about what this code is doing, the important property for us is that it&#x27;s configured correctly and will allow us to flash a corrected version of our code. So the procedure if you run into this problem is to set the Boot0 jumper to high (or hold down the button) while resetting the system. At this point the bootloader will be running, and we can re-flash the device. Next we&#x27;ll need to move the jumper back to low and reset again to switch back to our code. (Oh wow, I just had a flashback to a part-time tech-support job I had in university)&lt;&#x2F;p&gt;
&lt;p&gt;So that&#x27;s: &lt;strong&gt;reset with boot0 high, flash, reset with boot0 low&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Ignoring all the &lt;a href=&quot;https:&#x2F;&#x2F;image.easyeda.com&#x2F;histories&#x2F;f91e9cede2284268b11f976c1e5a62f6.png&quot;&gt;support circuitry on the blue pill development board&lt;&#x2F;a&gt;, here&#x27;s a schematic for what we need to add. The resistors will depend on your LEDs, their color and how bright you want them to be. I used 470Ω, but they are a little bright for my liking. Something larger would be better&lt;&#x2F;p&gt;
&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;14484419917e536000.png&quot; alt=&quot;I²C LED Display Schematic&quot;&#x2F;&gt;
&lt;p&gt;Let&#x27;s set up our I&#x2F;O accordingly&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa = device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIOA&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb2);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; leds = [
    gpioa.pa0.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa3.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa4.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa5.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa6.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
    gpioa.pa7.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_push_pull_output&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpioa.crl).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;downgrade&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(),
];
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Our leds are all on pins connected to the same general purpose I&#x2F;O port, GPIOA. This means they are all controlled by a single register. For this particular display, we could set all of our LEDs at once with a single write, and maybe I&#x27;ll try that later. Most of the time that&#x27;s not the best option. Most of the time we want to control each pin individually, hence the &lt;code&gt;split()&lt;&#x2F;code&gt; function above, that returns a structure that gives us access to the individual pins. &lt;&#x2F;p&gt;
&lt;p&gt;As you can see from the datasheet, or from this nice colorful pinout diagram most of the pins have more than one possible function.&lt;&#x2F;p&gt;
&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;c5044e442ad54ac400.jpg&quot; alt=&quot;STM32F103 Pinout Diagram&quot;&#x2F;&gt;
&lt;p&gt;Since the pins on the device have multiple functions, the types of our pin references reflect that. In the code above we set our LED pins to &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Push%E2%80%93pull_output&quot;&gt;push pull output&lt;&#x2F;a&gt; and then call &lt;code&gt;downgrade()&lt;&#x2F;code&gt; which erases the specific type and gives us a &lt;code&gt;Pxx&lt;&#x2F;code&gt; generic output pin that we can put into an array.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpiob = device.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;GPIOB&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;split&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb2);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; _scl = gpiob.pb6.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_alternate_open_drain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpiob.crl);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; _sda = gpiob.pb7.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;into_alternate_open_drain&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; gpiob.crl);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;re using the first I²C interface &lt;code&gt;I2C1&lt;&#x2F;code&gt;, so we&#x27;ll need to use pins PB6 and PB7. PB6 will be the clock signal, and PB7 will be the data. If you think about it, because of clock stretching, we&#x27;re also letting some data, data about back pressure, sneak into the clock signal.&lt;&#x2F;p&gt;
&lt;p&gt;We set these pins to their &lt;em&gt;alternate function&lt;&#x2F;em&gt; to tell the system to route the signal to the I²C interface. This also sets the pins to open drain. Since this is a shared bus, each device needs a way of sending signals that any of the others can detect. The way this works is we power the bus via the pullup resistors, ths provides the high signal. In out case, see the 10K resistors on the schematic. The open drain setting means that any device can sink current, pulling the signal low when it&#x27;s their turn to send. Our LEDs are set to push-pull meaning we drive current through the LEDs to turn them on, in the case of our I²C pins, we generate a signal pulse by pulling the pin low. &lt;&#x2F;p&gt;
&lt;p&gt;You may have pullup resistors or spaces for them on the device you want to connect to, for example, this Arduino Pro Mini has a footprint for adding some SMT pullups &lt;a href=&quot;https:&#x2F;&#x2F;www.sparkfun.com&#x2F;products&#x2F;11113&quot;&gt;Sparkfun Arduino Pro Nano&lt;&#x2F;a&gt;. You may be ok having multiple pullups on the bus, but be aware that you will have to consider your resistors as being in parallel.&lt;&#x2F;p&gt;
&lt;p&gt;You&#x27;ll notice that this is the only place we refer to our &lt;em&gt;scl&lt;&#x2F;em&gt; and &lt;em&gt;sda&lt;&#x2F;em&gt; pins. (I added the name with underscore basically as documentation.) This is because the rest of our communication will be done via the registers of the on chip I²C interface. If we had a full Rust HAL implementation we&#x27;d probably want to hand a reference to our SCL and SDA pins to that interface (here I&#x27;m speaking of an interface in the API sense). But in this case, since we are building an I²C Slave device we&#x27;re a little bit off the path and the HAL does not currently have a way of configuring slave devices. Most of the time people would be configuring the device as a Master and connecting various sensors and displays. What we are doing here is probably fairly rare.&lt;&#x2F;p&gt;
&lt;p&gt;No matter! We still have all the tools we need to configure it how we want. So let&#x27;s get to that. And maybe once I take a closer look at the abstractions in the HAL, I&#x27;ll contribute a PR to add functionality there.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;I2C1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;::enable(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb1);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;I2C1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;::reset(&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; rcc.apb1);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we enable the interface and reset it to a known state. It&#x27;s also not a bad idea to look both ways when crossing a one-way street.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;stm32f103-registers-and-i2c&quot;&gt;STM32F103 Registers and I²C&lt;&#x2F;h3&gt;
&lt;p&gt;To configure the interface correctly we&#x27;ll need to read the datasheet even closer. (It&#x27;s actually the Reference Manual, the datasheet concerns itself with more direct electrical and physical characteristics, but it&#x27;s the weekend, so I&#x27;m calling it the datasheet.) We&#x27;ll need to modify the contents of a few registers: I2C_CR1, I2C_CR2, and I2C_OAR1. The &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;stm32-rs&#x2F;stm32-rs&quot;&gt;peripheral access crates&lt;&#x2F;a&gt; are created based on vendor-provided description files, and provide structures we can use to access each register, named fields of the register, and the starting value at reset.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pe&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Interrupt enable for I2C
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.cr2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;itevten&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Since we are using a 7-bit address we need to shift it into bits 1:7 of OAR1:ADD
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.oar1
    .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;((&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;OUR_I2C_ADDRESS &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u16&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) &amp;lt;&amp;lt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;));

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; Enable i2c peripheral
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;pe&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ACK must be set after the peripheral is enabled or it will be ignored
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;First we need to disable the peripheral by clearing the PE bit in CR1. If we don&#x27;t do this, the reset of our setup will be ignored. I know this because of how carefully I read the datasheet, not because I tried it of course.&lt;&#x2F;p&gt;
&lt;p&gt;To act as an I²C slave device, we need a unique address. When we see our address on the bus, our interface will respond. I²C supports 7 and 10-bit addresses. Since we&#x27;re using a 7-bit address, and there is not a pre-built implementation to access this, we need to use the raw &lt;code&gt;bits()&lt;&#x2F;code&gt; function and shift our address over one bit to ADD bits 7–1. We can leave the ADDMODE at the reset value of 0 to specify that we want slave mode. We would need to set this bit to operate as a master device.&lt;&#x2F;p&gt;
&lt;p&gt;Next we&#x27;ll need to enable interrupt events with ITEVTEN in CR2. Wait, didn&#x27;t we already do that? Well, not exactly. We did set up an interrupt vector which tells the compiler and friends to set up a table with the address of our interrupt handler, so we&#x27;ll jump there on an interrupt. This it to tell the I²C interface that, yes, we do want those interrupt events to be generated.&lt;&#x2F;p&gt;
&lt;p&gt;Now we can set the peripheral enable flag back to on in CR1. &lt;&#x2F;p&gt;
&lt;p&gt;The last bit of preparation is to set the ACK to enabled so that once we see our address on the bus, the interface will be ready to automatically acknowledge it and send us an interrupt. This has to be set &lt;em&gt;after&lt;&#x2F;em&gt; the interface is re-enabled, or it will be ignored. Again, this is totally obvious from the datasheet, how could it work any other way really.&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;It&#x27;s important to be able to see what is going on, especially when you have things like peripherals that ignore your input when in certain modes. There&#x27;s a good intro to the OpenOCD debugger &lt;a href=&quot;https:&#x2F;&#x2F;docs.rust-embedded.org&#x2F;discovery&#x2F;05-led-roulette&#x2F;debug-it.html&quot;&gt;in the Discovery Book&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;You can also use the &lt;a href=&quot;https:&#x2F;&#x2F;probe.rs&#x2F;guide&#x2F;1_tools&#x2F;cargo-embed&#x2F;&quot;&gt;probe-rs tools&lt;&#x2F;a&gt; to send debug information to your development host. It&#x27;s non-trivial to format strings on the target device, &lt;code&gt;rprintln&lt;&#x2F;code&gt; is great because it supports the &lt;code&gt;println&lt;&#x2F;code&gt; syntax but defers the formatting to run on the debugging host. Note that even with this deferral we will still stall when logging. Logging from within the I2C1_EV interrupt can be useful, but it will alter the timing and thus, ultimately, the behavior.&lt;&#x2F;p&gt;
&lt;p&gt;To really debug the communication between devices you&#x27;ll want a logic analyzer or oscilloscope. Can you imagine trying to sort out the clock masking bug I mentioned above without one? &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;        rtic::pend(Interrupt::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;I2C1_EV&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Logically last, we want to enable the interrupts. By that I mean that we wouldn&#x27;t want to jump to an interrupt handler some time during setup when we are in an inconsistent state, so that&#x27;s why it&#x27;s the last line here. In the case of RTIC, interrupts are disabled during init, so we could have enabled it sooner with no ill effects.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;handling-the-interrupt&quot;&gt;Handling the Interrupt&lt;&#x2F;h3&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;task&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(binds = I2C1_EV, resources = [i2c, leds], priority = 2)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;i2c1_ev&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: i2c1_ev::Context) {
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i2c = c.resources.i2c;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; leds = c.resources.leds;

  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1 = i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();

  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ADDR: Our address was matched on the bus
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    i2c.sr2.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
  }
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rx_ne&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; RX_NE: receive buffer not empty
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;output_leds&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(leds, i2c.dr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bits&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() as &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
  }
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stopf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; STOPF: End of transmission
    &#x2F;&#x2F; Datasheet: The STOPF bit is cleared by a read of the SR1 register
    &#x2F;&#x2F; followed by a write to CR1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| {
      w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
      w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
    });
  }
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;af&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; AF: Failed to acknowledge
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;    i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|_, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;af&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;clear_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;());
  }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Whenever the I²C interface finishes receiving a full byte of data or encounters any other condition, it sets various flags in status registers and triggers an interrupt. The interrupt handler&#x27;s job is to read the data and acknowledge conditions, by clearing the appropriate flags. For example, the ADDR flag in the status register SR1 indicates that our address was acknowledged, and RX_NE indicates that we have data waiting to be read. In this last case, the very act of reading the register also servers to clear the status condition. If for some reason we were ultimately going to discard the data, say for example the host sent us an extra byte out of spec, we would still need to read the register to signal the device to continue. In the case of the ned of transmission STOPF bit, according to the datasheet, we need to read SR1 (again) followed by a write to CR1.&lt;&#x2F;p&gt;
&lt;p&gt;Since the whole point of these registers is that their content will change outside the scope of our code, they are marked as volatile. It&#x27;s handy to use the same methods of accessing these registers that we use for general purpose memory, but we don&#x27;t want the compiler to optimize away operations that appear locally to be redundant.&lt;&#x2F;p&gt;
&lt;p&gt;Similarly, we would not want to do the following:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stopf&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; i2c.sr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;read&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;rx_ne&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;bit_is_set&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#65737e;&quot;&gt;&#x2F;&#x2F; ...
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We might expect the compiler to optimize away the extra reads if these were not volatile locations, but here, if we were to do this, each call would perform a read of the register. Not only would this be inefficient, it would also be incorrect. Since our reads and writes have side effects, we need to be mindful of when they happen.&lt;&#x2F;p&gt;
&lt;p&gt;When we do &lt;code&gt;let sr1 = i2c.sr1.read();&lt;&#x2F;code&gt; we have a proxy object containing the read value. We can check this as many times as we like without invoking additional register reads.&lt;&#x2F;p&gt;
&lt;p&gt;To modify particular fields of a register, leaving the other fields as-is we do this:&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;i2c.cr1.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;w&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;| {
    w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;ack&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
    w.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;stop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_bit&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;()
});
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;modify&lt;&#x2F;code&gt; takes a closure that gives us the pre-modification state with value &lt;code&gt;r&lt;&#x2F;code&gt;. We write the new value with &lt;code&gt;w&lt;&#x2F;code&gt; which lets us specify field by field but when invoked, does a single read, modify and single write. For more, see the documentation in &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;svd2rust&#x2F;0.19.0&#x2F;svd2rust&#x2F;index.html#read--modify--write-api&quot;&gt;svd2rust&lt;&#x2F;a&gt; &lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s step through the basics of the communication.&lt;&#x2F;p&gt;
&lt;img src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;processed_images&amp;#x2F;22d5e670ffdeac1e00.png&quot; alt=&quot;I2C communication diagram from specification&quot;&#x2F;&gt;
&lt;p&gt;The master device sets the data signal low before the clock to signal the start condition. The address of our device is then sent on the bus, we get an interrupt request with the SR1 ADDR flag set. We clear that by reading SR1 and SR2. The interface sends an acknowledge pulse. The master sends data bytes. We read each byte (and thus clear the status). The master sends a stop condition. We clear that with an SR1 read, and a write to CR1, setting the state back into the ready to acknowledge state.&lt;&#x2F;p&gt;
&lt;p&gt;Each byte we receive, we write directly to our array of leds. This is fairly simple, so we can get away with running it inside our interrupt handler.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;output_leds&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;leds&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt; [Pxx&amp;lt;Output&amp;lt;PushPull&amp;gt;&amp;gt;; 8], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;value&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;) {
    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(i, led) in leds.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;iter_mut&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;enumerate&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(value &amp;gt;&amp;gt; i) &amp;amp; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;1 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
            led.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_high&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;{
            led.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;set_low&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#96b5b4;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
        }
    }
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Here we run through our LEDs, shift and mask test our value to turn on the LEDs corresponding to the 1s in our input.&lt;&#x2F;p&gt;
&lt;p&gt;That&#x27;s everything we need for a basic I²C 8-bit display. If you are building this yourself, see the &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;led-test&lt;&#x2F;a&gt; for an example without interrupts or I²C that you can use to make sure everything is connected correctly and everything lights up as it should.&lt;&#x2F;p&gt;
&lt;p&gt;We are going to use an Arduino as our example host device.&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#2b303b;&quot;&gt;
&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;#include &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a3be8c;&quot;&gt;Wire.h&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;&amp;gt;

byte the_count;

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;setup&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;begin&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
  the_count = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;;
}

&lt;&#x2F;span&gt;&lt;span style=&quot;color:#b48ead;&quot;&gt;void &lt;&#x2F;span&gt;&lt;span style=&quot;color:#8fa1b3;&quot;&gt;loop&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;() {
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;beginTransmission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;0x33&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;write&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(the_count);     
  Wire.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;endTransmission&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;();
  the_count++;
  &lt;&#x2F;span&gt;&lt;span style=&quot;color:#bf616a;&quot;&gt;delay&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#d08770;&quot;&gt;80&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c0c5ce;&quot;&gt;);
}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We&#x27;ll use the Wire library to send a count, making each byte a separate transaction.&lt;&#x2F;p&gt;
&lt;p&gt;Let&#x27;s give it a try.&lt;&#x2F;p&gt;
&lt;div class=&quot;loopvid&quot;&gt;
    &lt;video autoplay loop muted playsinline&gt;
        &lt;source src=&quot;https:&amp;#x2F;&amp;#x2F;proto.typi.ca&amp;#x2F;vid&amp;#x2F;pink-led-bar.mp4&quot; type=&quot;video&#x2F;mp4&quot; alt=&quot;Pink Counting LEDs&quot;&gt;
    &lt;&#x2F;video&gt;
&lt;&#x2F;div&gt;
&lt;h3 id=&quot;what-s-next&quot;&gt;What&#x27;s Next&lt;&#x2F;h3&gt;
&lt;p&gt;You can find the code &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jspencer&#x2F;custom-i2c-displays&quot;&gt;here&lt;&#x2F;a&gt;. Feel free to add a GitHub issue if you run into problems or have questions about making something similar.&lt;&#x2F;p&gt;
&lt;p&gt;See the &lt;a href=&quot;https:&#x2F;&#x2F;proto.typi.ca&#x2F;rust-i2c-bubble-display&#x2F;&quot;&gt;next post&lt;&#x2F;a&gt; for the 7-segment display where I add a few new features.&lt;&#x2F;p&gt;
&lt;p&gt;For me, I might take a look at adding I²C slave support to the libraries. I also will probably port this to another chip. With the current component shortage, everything is hard to find, but I suspect even once we get rolling again, we&#x27;ll move on to more capable chips at this same price. So check back for that if you have an STM32F4xx based device.&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
